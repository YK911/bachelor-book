# Функції. Директива @function

Уявімо ситуацію, в якій ми хочемо написати міксин з функціоналом для додаткової обробки параметрів. Звичайно, можна це зробити в середині цього ж міксина, але що робити, коли точно така ж обробка буде потрібна і в іншому місці нашого коду. Дублювати один і той самий код від міксина до міксина було би помилкою і порушенням принципу DRY (Don't repeat yourself) для написання чистого і підтримуваного коду.

Вихід є! Завдяки директиві `@function` препроцесора Sass ми можемо створити блок коду з набором складних операцій для обробки даних, повернути результат і повторити ці операції стільки разів, скільки нам буде потрібно, викликаючи функцію в тому місці, де це необхідно.

Функції дозволяють легко абстрагувати загальні формули, поведінку таблиць стилів в зрозумілий спосіб та зменшують кількість повторень коду.

Функції визначаються за допомогою директиви `@function`, яка записується наступним чином:

```scss
// Function statement

@function <name>(<arguments...>) {
    ...
    @return <value>
}

// <name> - імʼя фукнції
// <arguments...> - перелік аргументів функції (внутрішні змінні доступні в середині функції)
// { ... } - тіло функції, використовується для опису комплексу операції
// @return - обовʼязкова директива, яка використовується для того, щоб повернути з функції результат роботи комплексу вказаних операцій
```

Для того, щоб застосувати функцію достатньо вказати її імʼя і передати набір аргументів у круглих дужках.

> У назвах функцій дефіси та підкреслення є ідентичними. Це означає, що `round-value` і `round_value` стосуються однієї і тої функції. Це історичний пережиток Sass, коли для неймінгу у препроцесорі дозволялося використовувати лише нижні підкреслення в іменах ідентифікаторів. Після того, як в Sass було додано підтримку дефісів, щоб вони відповідали синтаксису CSS, їх зробили еквівалентними до нижніх підкресувань, щоб спростити міграцію.

Перейдемо до реального прикладу з практики.

Навколо роботи одиниць виміру у Sass існує багато плутанини. Однак вони працюють точно так само, як і в реальному житті. Якщо ви хочете видалити одиницю вартості, її потрібно розділити на 1 одиницю. Наприклад, щоб видалити одиницю вимірювання сантиметри для `42см`, потрібно розділити її на `1см`. Точно така ж логіка працює і в Sass.

```scss
$font-size: 24px;
$value: $font-size / 1px;
// result -> 24
```

Та проблеми починаються тоді, коли ми не знаємо одиниці вимірювання, які використовуються. Скажімо, це може бути будь-що, починаючи з пікселів до `em` або навіть `vw` і `ch`. В такому випадку нам потрібно абстрагувати логіку для обчисленя значення.

```scss
@use "sass:math"; // don't forget to import math module
/// Remove the unit of a length
/// @param {Number} $number - Number to remove unit from
/// @return {Number} - Unitless number
@function strip-unit($value) {
  @if type-of($value) != number {
    @error '#{ $value } is not a number.';
  }

  @if type-of($value) == "number" and not unitless($value) {
    @return math.div($value, ($value * 0 + 1));
  }

  @return $value;
}

/* ===== Usage ===== */
$font-size: 24px;
$value: strip-unit($font-size);
@debug $value;
// -> 24
```

Тут варто зупинитись та детально розібратись із тим, що ж відбувається з кодом:

* ми імпортували модуль `sass:math` з математичними функціями для виконання операції ділення (`math.div`)
* використали директиву `@function` для позначення функції, та задали їй імʼя `strip-unit`
* наша функція приймає всього один параметр `$value`
* за допомогою умовного оператора `@if` та вбудованих функцій ми перевіряємо чи тип змінної `$value` це число (`type-of()`) та чи містить змінна одиниці виміру (`not unitless()`)
* якщо ми пройшли перевірку і аргумент при виклику функції містить одиниці виміру, то ми їх видаляємо
* особливість у тому, що при обрахунку виразу `$value * 0` ми отримаємо значення `0px` і при додаванні `0px + 1` отримаємо одиницю з відповідним значенням одиниць виміру `1px`
* далі всю роботу за нас зробить операція ділення: поділивши `px / px` та відповідне значення на одиницю ми отримуємо результат без одиниць виміру
* отримавши результат ми повертаємо його за допомогою обовʼязкової директиви `@return`, яка в свою чергу припиняє роботу функції повертаючи значення; код вказаний після директиви `@return` не виконується
* у випадку якщо при виклику функції було передано число без одиниць виміру, перевірка `@if` не спрацює і нам повернеться це ж число

Тепер спробуємо використати нашу функцію для поліпшення роботи міксину і мінімізації помилок при його використанні.

Маємо міксин для роботи з текстовими властивостями елементів:

```scss
/// Set text properties to element
@mixin fonts($fs, $fw: null, $lh: null, $ls: null, $align: null) {
  @if $fs { font-size: $fs; }

  @if $fw { font-weight: $fw; }

  @if $lh {
    @if $lh == normal {
      line-height: normal;
    } @else if math.unit($lh) == "px" {
      line-height: calc($lh / $fs);
    } @else {
      @error "$lh value #{$lh} is incorrect";
    }
  }

  @if $ls {
    @if $ls == normal {
      letter-spacing: normal;
    } @else {
      letter-spacing: #{calc($ls / $fs)}em;
    }
  }

  @if $align { text-align: $align; }
}
```

Як видно з коду, у нашого міксина є декілька слабких місць, в яких може статись помилка.

1. При обрахунку значення властивості `line-height` ми обробляємо лише випадок, коли одиниці виміру відповідають `px`.
2. При обрахунку значення властивості `letter-spacing` ми ніяким чином не обробляємо значення параметрів `$ls` та `$fs` і у випадку якщо хоча б один із них буде без одиниць виміру ми отримаємо некоректний результат, наприклад:

```css
letter-spacing: 0.025pxem;
```

3. В результаті виконання операції ділення ми можемо отримувати доволі великі значення для чисел з плаваючою комою і було би добре округлювати їх до певного знаку після коми.

Тому, для вирішення цих проблем ми можемо використати функцію `strip-unit()`, яка гарантовано поверне нам числове значення, та запозичимо функцію `round()` (посилання зберігається без змін) для округлень. Відкоригуємо наш код:

```scss
@use "sass:math";
@use "decimal" as d; // import all functions from module

@function strip-unit($value) {
  @if type-of($value) == "number" and not unitless($value) {
    @return math.div($value, ($value * 0 + 1));
  }

  @return $value;
}

/// Set text properties to element
@mixin fonts($fs, $fw: null, $lh: null, $ls: null, $align: null) {
  @if $fs { font-size: $fs; }

  @if $fw { font-weight: $fw; }

  @if $lh {
    @if $lh == normal {
      line-height: normal;
    } @else {
      $lh: calc(strip-unit($lh) / strip-unit($fs));
      line-height: d.decimal-round($lh, 2);
    }
  }

  @if $ls {
    @if $ls == normal {
      letter-spacing: normal;
    } @else {
      $ls: calc(strip-unit($ls) / strip-unit($fs));
      letter-spacing: #{d.decimal-round($ls, 2)}em;
    }
  }

  @if $align { text-align: $align; }
}
```

Тепер наш код буде працювати стабільніше, навіть якщо колега-розробник забуде вказати одиниці виміру для властивостей при використанні даного міксину.

{% hint style="info" %}
Перевага використання такого підходу у тому, що при роботі з Figma, у більшості випадків, значення отриманих властивостей з макету вказані саме у пікселях.
{% endhint %}

Додатково розглянемо приклад роботи функцій для конвертації значень, вказаних в пікселях в одиниці виміру `rem/em`.

При роботі з респонсивною версткою доволі часто потрібно робити обрахунки з конвертації абсолютних одиниць виміру `px` у відносні `rem/em`.

Щоб кожного разу не виконувати обрахунки, автоматизуємо цей процес за допомогою функції. Приймемо, що наша функція буде працювати зі значеннями у `px` взятих з макету Figma.

```scss
@use "sass:math";
@function strip-unit($value) {
  @if type-of($value) == "number" and not unitless($value) {
    @return math.div($value, ($value * 0 + 1));
  }

  @return $value;
}
// Set px to rem/em
@function rem($px-value, $base-font-size: 16px) {
  @return #{strip-unit($px-value) / strip-unit($base-font-size)}rem;
}

@function em($px-value, $base-font-size: 16px) {
  @return #{strip-unit($px-value) / strip-unit($base-font-size)}em;
}

/* ===== Usage ===== */
.container {
  width: rem(1000px); // or rem(1000)
}
// width: 62.5rem;
```
