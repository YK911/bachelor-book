# Вбудовані модулі Sass

### Концепція стандартної бібліотеки Sass

У попередніх версіях Sass розробники покладалися на глобальні функції (такі як `lighten()`, `map-get()`, `unquote()`). Це створювало дві проблеми:

1. Забруднення глобального простору імен: існував ризик конфлікту імен функцій Sass з новими функціями чистого CSS (як це сталося з `filter` або `min/max`).
2. Неочевидність походження: у великому проєкті було важко зрозуміти, звідки прийшла функція — з бібліотеки чи це кастомна розробка.

Сучасна специфікація Sass пропонує Вбудовані модулі (Built-In Modules). Це набір спеціалізованих інструментів, згрупованих за призначенням, які необхідно явно імпортувати. Це робить код більш структурованим та безпечним.

Sass надає наступний набір вбудованих модулів:

* `sass:math` забезпечує функціонал для виконання операцій над числами (математичні обчислення, округлення, тригонометрія).
* `sass:string` спрощує роботу з текстовими рядками, дозволяючи об'єднувати їх, здійснювати пошук підрядків або розбивати текст на частини.
* `sass:color` генерує нові кольори на основі існуючих, що значно полегшує побудову кольорових схем (тем).
* `sass:list` надає інструменти для доступу до елементів списків та їх модифікації.
* `sass:map` дозволяє працювати з асоціативними масивами (maps), зокрема отримувати значення, пов'язане з певним ключем, та виконувати інші операції зі структурованими даними.
* `sass:selector` надає програмний доступ до потужного рушія обробки селекторів Sass (дозволяє маніпулювати вкладеністю та структурою селекторів).
* `sass:meta` розкриває деталі внутрішньої роботи Sass (дозволяє проводити інтроспекцію коду, перевіряти типи даних та існування міксинів).

***

### Модуль `sass:math`: Більше, ніж просто арифметика

Цей модуль є критично важливим для створення гнучких сіток (grids), обчислення пропорцій та роботи з тригонометрією.

Імпорт: `@use "sass:math";`

#### Проблема ділення (`/`)

Історично в CSS символ `/` використовується як роздільник (наприклад, `font: 16px/20px` або `grid-row: 1 / 3`). У Sass він також означав ділення. Щоб усунути цю двозначність, Sass оголосив використання `/` для ділення deprecated (застарілим).

Для математичного ділення рекомендується використовувати функцію `math.div()`.

```scss
@use "sass:math";

.col-6 {
  // ЗАСТАРІЛО (викличе попередження компілятора):
  // width: 100% / 2;

  // ПРАВИЛЬНО:
  width: math.div(100%, 2);
}

.sidebar {
  // Округлення значень
  padding: math.floor(10.6px); // Результат: 10px
  margin-top: math.ceil(10.1px); // Результат: 11px
  
  // Обмеження значень (clamp)
  width: math.clamp(300px, 50%, 800px);
}
```

#### Сумісність одиниць

Модуль вміє перевіряти, чи можна проводити операції між різними одиницями виміру.

```scss
@debug math.compatible(10px, 2em); // false (не можна просто додати px до em без контексту)
@debug math.compatible(10cm, 1in); // true (обидві є одиницями довжини)
```

***

### Модуль `sass:color`: Програмна робота з дизайном

У професійній розробці інтерфейсів (UI Engineering) ми уникаємо "хардкоду" кольорів. Ми використовуємо базові змінні та програмно їх модифікуємо для створення станів (`:hover`, `:active`, `:focus`).

Імпорт: `@use "sass:color";`

#### Трансформація кольору: `color.scale` vs `lighten/darken`

Раніше розробники використовували функції `lighten()` та `darken()`. Однак ці функції працюють лінійно і часто призводять до того, що світлі кольори швидко стають білими, а темні — чорними.

Сучасний стандарт рекомендує `color.scale()`. Ця функція змінює властивості кольору у відсотковому співвідношенні, зберігаючи "насиченість" та "характер" кольору.

```scss
@use "sass:color";

$brand-blue: #007bff;

.btn-primary {
  background-color: $brand-blue;
  
  &:hover {
    // Змінюємо світлість (lightness) на -20% (робимо темнішим)
    // Це надійніше, ніж darken($brand-blue, 20%)
    background-color: color.scale($brand-blue, $lightness: -20%);
  }
  
  &:disabled {
    // Змінюємо прозорість (alpha channel)
    background-color: color.change($brand-blue, $alpha: 0.5);
  }
}
```

#### Маніпуляція каналами

Ви можете отримати окремі компоненти кольору для складних обчислень або генерації CSS змінних.

```scss
$red-component: color.channel(#ff0000, "red", $space: rgb);
```

***

### Модуль `sass:meta`: Інтроспекція

Цей модуль дозволяє Sass аналізувати сам себе. Це рівень метапрограмування, корисний для створення бібліотек.

Імпорт: `@use "sass:meta";`

* `meta.type-of($value)` — повертає тип даних (number, string, color, list, map). Аналог `typeof` у JS.
* `meta.calc-args()` — дозволяє розібрати аргументи всередині CSS функції `calc()`.

Приклад "розумного" міксина, який перевіряє вхідні дані:

```scss
@mixin set-radius($val) {
  @if meta.type-of($val) != "number" {
    @error "Очікувалось число, отримано #{meta.type-of($val)}";
  }
  border-radius: $val;
}
```

***

### Модулі `sass:map` та `sass:list`: Структури даних

У великих дизайн-системах (Design Systems) усі параметри (шрифти, відступи, кольори) зберігаються у змінних-мапах. Це дозволяє централізовано керувати темою сайту.

Імпорт: `@use "sass:map";`

#### Робота з мапами (Maps)

Мапи — це аналог об'єктів у JavaScript або словників у Python.

```scss
@use "sass:map";

// Конфігурація брейкпоінтів (точок зламу адаптиву)
$breakpoints: (
  "sm": 576px,
  "md": 768px,
  "lg": 992px
);

@mixin respond-to($size) {
  // Отримуємо значення за ключем
  $width: map.get($breakpoints, $size);
  
  // Перевірка на помилку (якщо ключа не існує)
  @if $width {
    @media (min-width: $width) {
      @content;
    }
  } @else {
    @error "Брейкпоінт #{$size} не знайдено.";
  }
}
```

#### Злиття налаштувань (Merge)

Функція `map.merge()` дозволяє об'єднувати дві мапи. Це стандартний патерн для створення компонентів, які мають налаштування за замовчуванням, але можуть бути перевизначені користувачем.

```scss
$default-config: ("color": #333, "padding": 10px);
$user-config: ("color": #ff0000); // Користувач хоче змінити лише колір

// Результат: ("color": #ff0000, "padding": 10px)
$final-config: map.merge($default-config, $user-config);
```

{% hint style="success" %}
_Вивчення вбудованих модулів — це перехід від "верстальника" до "інженера інтерфейсів". Використовуйте документацію Sass як настільну книгу, оскільки синтаксис функцій може оновлюватись._
{% endhint %}
