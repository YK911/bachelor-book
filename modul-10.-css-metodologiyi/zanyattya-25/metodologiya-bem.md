# Методологія BEM

[**Методологія БЕМ (Блок, Елемент, Модифікатор)**](https://en.bem.info/methodology/quick-start/) створена для розробки сайтів, які необхідно робити швидко, а підтримувати довгі роки. Вона дозволяє створювати блоки інтерфейсу, які можна розширювати та повторно використовувати — компоненти.

<figure><img src="../../.gitbook/assets/bem.png" alt=""><figcaption></figcaption></figure>

Це не тільки метод іменування класів, але в першу чергу парадигма сприйняття проєкту як набору сутностей (блоки, елементи, модифікатори), які можна змішувати і зіставляти для створення інтерфейсів як конструктор LEGO. Вона менш заплутана, ніж інші, і надає гарну архітектуру з впізнаваною термінологією.

Переваги:

* **Простота селекторів** — всі селектори — це класи, тому ви не будете працювати з каскадом. BEM уникає конфліктів імен, використовуючи унікальні контекстні імена класів для кожного блоку, елемента і модифікатора.
* **Повторне використання** — створюючи незалежні компоненти, ви можете повторно використовувати їх в поточному та інших проєктах.
* **Структура стилів** — методологія дає вашому CSS-коду структуру, яка залишається простою і зрозумілою.
* **Самодокументування** — строгі правила іменування класів призводять до зрозумілої HTML-розмітки і впорядкованих стилів. Вивчаючи елемент або блок, ви отримуєте всю необхідну інформацію безпосередньо з HTML-розмітки.

***

### Блок

**Блок** - функціонально незалежний компонент, який може використовуватися повторно. Блок можна поставити в іншу частину сторінки або проекту, і він буде мати сенс. Наприклад, блоком може бути галерея, стаття, шапка, форма, віджет сайдбара, сам сайдбар, навігація тощо.

Ім'я класу блоку:

* **Може** складатися тільки з латинських літер, цифр і тире.
* **Повинно** відповідати на питання «Що це?» — `widget`, `gallery`, `navigation`, `post`.
* **Не повинно** відповідати на питання «Як виглядає?» — `red-text`, `round-button` тощо.

{% code title="Приклад HTML" %}
```html
<!-- В HTML і CSS, блок - це просто базовий клас компонента -->
<a class="logo"></a>

<p class="alert"></p>

<ul class="gallery"></ul>

<article class="product"></article>

<section class="section"></section>

<header class="page-header"></header>
```
{% endcode %}

## Вкладеність

Блоки можна і потрібно вкладати один в одного, обмежень немає, крім здорового глузду і специфікації HTML, оскільки вони представлені тегами. Вкладені блоки не мають жодних додаткових особливостей, пріоритету або ієрархії.

{% code title="Приклад вкладеності" %}
```html
<!-- Блок page-header -->
<header class="page-header">
  <!-- Вкладений блок logo -->
  <a href="" class="logo"></a>

  <!-- Вкладений блок navigation -->
  <ul class="navigation">
    ...
  </ul>
</header>
```
{% endcode %}

***

### **Елемент**

**Елемент** - це складова частина блоку, яка не має окремого значення і не може використовуватися окремо від нього. Наприклад, елемент меню, заголовок або текст у статті, зображення галереї тощо.

Ім'я класу елемента:

* **Обов'язково** формується за схемою `блок__елемент`. Ім'я блоку задає простір імен, який гарантує залежність його елементів.
* **Повинно** відповідати на питання «Що це?», наприклад `блок__item`, `блок__title`, `блок__link`, `блок__image` тощо.
* **Не повинно** відповідати на питання «Як виглядає?», наприклад `блок__big-link`, `блок__blue-text`, `блок__round-button` тощо.

```html
<!-- ✅ Блок logo з елементами image і label -->
<a href="" class="logo">
  <img class="logo__image" src="..." alt="Логотип компанії Технокряк" />
  <span class="logo__label">Компанія Технокряк</span>
</a>

<!-- ❌ Елемент за межами блоку не має окремого значення -->
<img class="logo__image" src="..." alt="Логотип компанії Технокряк" />

<!-- ✅ Блок product з елементами name, price і link -->
<article class="product">
  <h1 class="product__name">Холодильник</h1>
  <p class="product__price">Ціна: 30000</p>
  <a class="product__link" href="">Переглянути всі характеристики</a>
</article>

<!-- ❌ Елемент за межами блоком не має окремого значення -->
<h1 class="product__name">Холодильник</h1>
```

{% hint style="info" %}
Як відрізнити блок від елементу?

Задайте собі питання: «Ця сутність може знадобитися мені окремо і самостійно? Чи вона потрібна тільки всередині її батька?». Якщо потрібна окремо - це блок, якщо має значення тільки як частина - це елемент.
{% endhint %}

## Вкладеність

Елементи можна вкладати один в одного, водночас допустима будь-яка вкладеність, оскільки BEM-класи не прив'язані до HTML-ієрархії. HTML-структура елементів блоку може бути довільною.

Навігація - це блок, а елемент списку і посилання - це елементи блоку навігації.

```html
<ul class="nav">
  <li class="nav__item">
    <a class="nav__link" href="">Про нас</a>
  </li>
  <li class="nav__item">
    <a class="nav__link" href="">Контакти</a>
  </li>
  <li class="nav__item">
    <a class="nav__link" href="">Галерея</a>
  </li>
</ul>
```

Структура BEM-класів такого компонента буде плоскою.

```scss
.nav {}
.nav__item {}
.nav__link {}
```

Додамо BEM-класи до розмітки картки продукту з декількома рівнями вкладеності.

```html
<article class="product">
  <div class="product__overlay">
    <img class="product__image" src="" />
  </div>

  <div class="product__content">
    <h2 class="product__name">Холодильник</h2>
    <p class="product__description">Шикарний холодильник</p>
    <a class="product__link" href="">Переглянути всі характеристики</a>

    <div class="product__meta">
      <p class="product__price">Ціна: 30000</p>
      <p class="product__quantity">Залишилось: 8 штук</p>
    </div>
  </div>
</article>
```

Структура BEM-класів блоку та його елементів **завжди буде плоскою**, незалежно від глибини вкладеності елементів один в одного. Це дозволяє змінювати структуру HTML-розмітки блоку без внесення змін у стилі.

```scss
.product {}
.product__overlay {}
.product__image {}
.product__content {}
.product__name {}
.product__description {}
.product__link {}
.product__meta {}
.product__price {}
.product__quantity {}
```

{% hint style="warning" %}
Увага

**Елемент** - завжди частина блоку, а не іншого елемента. Це означає, що в імені класу елемента не можна прописувати ієрархію на зразок `блок__елемент1__елемент2`.
{% endhint %}

## Необов'язковість

Елемент - це необов'язкова частина блоку. Не у всіх блоків повинні бути елементи і не усі елементи можуть бути присутніми у різних екземплярах блоку.

```html
<!-- Блок button з іконкою і текстом -->
<button class="button" type="button">
  <svg class="button__icon">...</svg>
  <span class="button__label">В кошик</span>
</button>

<!-- Блок button тільки з текстом -->
<button class="button" type="button">
  <span class="button__label">В кошик</span>
</button>

<!-- Блок button тільки з іконкою -->
<button class="button" type="button">
  <svg class="button__icon">...</svg>
</button>
```

***

### Модифікатор

**Модифікатор** - це додатковий клас, що визначає зміну зовнішнього вигляду, стану або поведінки блоку або елемента.

Ім'я класу модифікатора:

* **Повинно** бути простим, що описує зміну, яка вноситься.
* **Обов'язково** формується за схемою `блок--модифікатор` або `блок__елемент--модифікатор`.

Клас-модифікатор ніколи не повинен використовуватися самостійно, а тільки разом із тим класом блоку або елемента, який він доповнює. У прикладі імена модифікаторів вказують тип повідомлення.

```html
<!-- ✅ Є базовий клас -->
<p class="alert"></p>

<!-- ✅ Є базовий клас і клас-модифікатор -->
<p class="alert alert--success"></p>
<p class="alert alert--error"></p>
<p class="alert alert--warning"></p>

<!-- ❌ Немає базового класу, немає значення -->
<p class="alert--success"></p>
```

Базові стилі блоку або елемента записуються в їхньому класі. Клас-модифікатор може додавати нові або перевизначати вже існуючі властивості.

{% embed url="https://codepen.io/YK911/embed/XJXZKmy?default-tab=html%2Cresult" %}

## Кнопка-конструктор

Створимо компонент кнопки з іконкою і текстом. Кнопка - це блок, іконка і текст - його необов'язкові елементи.

```html
<button class="button" type="button">
  <svg class="button__icon">...</svg>
  <span class="button__label">В кошик</span>
</button>
```

Для того щоб задати відступ між іконкою і текстом, необхідно вказати `margin`, наприклад іконці.

```scss
.button__icon {
  margin-right: 10px;
}
```

Проблема такого рішення в тому, що елементи — це необов'язкова частина блоку та їх HTML-структура може бути довільною. Іконка може бути праворуч від тексту, тоді у неї буде зайвий правий відступ, а потрібен лівий. Тексту може не бути зовсім, тоді і відступи не потрібні.

```html
<!-- Іконка після тексту -->
<button class="button" type="button">
  <span class="button__label">В кошик</span>
  <svg class="button__icon">...</svg>
</button>

<!-- Текст відсутній -->
<button class="button" type="button">
  <svg class="button__icon">...</svg>
</button>
```

Вирішити це завдання допоможуть модифікатори. Додамо іконці два модифікатора стану — `start` і `end` (їх так само можна було назвати, наприклад, `left` і `right`). У цих класах-модифікаторах запишемо стилі для відступів.

```scss
.button__icon--start {
  margin-right: 10px;
}

.button__icon--end {
  margin-left: 10px;
}
```

Тепер ми можемо комбінувати елементи кнопки як конструктор LEGO, і нічого не буде зайвим і не зламається. Все тому, що базові класи блоку та елементів містять загальні стилі для всіх їх варіацій, а модифікатори змінюють стилі у разі потреби.
