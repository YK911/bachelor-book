# Flow-control директиви: @if | @each | @for

## Flow-control. Директиви @if, @each, @for

Препроцесор Sass надає функціонал для контролю потоку виконання коду. Для цього використовуються такі директиви як `@if`, `@else` та `@else if`.

Принцип роботи простий - результат умови приводиться до **`truthy`** або **`falsy`** значення, після чого потік програми спрямовується в ту або іншу гілку.

**Truthy** і **Falsy** - терміни, які використовуються для тих значень, які в логічній операції приводяться до `true` або `false`.

Під час виконання директиви `@if` вираз повертає `true` або `false`, відповідно якщо вираз повертає `true`, блок після `@if` виконується, а якщо вираз повертає `false`, ні.

{% code overflow="wrap" lineNumbers="true" %}
```scss
// @if statement
@mixin avatar($size, $circle: false) {
  width: $size;
  height: $size;

  @if $circle {
    border-radius: $size / 2;
  }
}

/* ===== Usage ===== */
.square-avatar {
  @include avatar(100px, $circle: false);
}
.circle-avatar {
  @include avatar(100px, $circle: true);
}
```
{% endcode %}

> У препроцесорі Sass до **falsy значень** відносяться `false` та `null`, все інше є **truthy значеннями** і приводиться до `true`

Розглянемо приклад застосування розгалудження з декількома перевірками.

{% code overflow="wrap" lineNumbers="true" %}
```scss
@use "sass:math";

// Conditional statements
@mixin fonts($fs, $fw: null, $lh: null, $ls: null, $align: null) {
  @if $fs { font-size: $fs; }

  @if $fw { font-weight: $fw; }

  @if $lh {
    @if $lh == normal {
      line-height: normal;
    } @else if math.unit($lh) == "px" {
      line-height: calc($lh / $fs);
    } @else {
      @error "$lh value #{$lh} is incorrect";
    }
  }

  @if $ls {
    @if $ls == normal {
      letter-spacing: normal;
    } @else {
      letter-spacing: #{calc($ls / $fs)}em;
    }
  }

  @if $align { text-align: $align; }
}

/* ===== Usage ===== */
.title {
  // Without keyword args
  @include fonts(20px, 600, 28px, 0.5px, center);
}
.title {
  // With keyword args
  @include fonts(20px, $fw: 600, $lh: 28px, $ls: 0.5px, $align: center);
}
```
{% endcode %}

Поки у вашому коді немає складної логіки, немає потреби і в умовних операторах. Фактично, вони переважно потрібні для бібліотек і фреймворків.

Проте, якщо вам коли-небудь знадобиться використовувати їх, будь ласка, дотримуйтесь наступних рекомендацій:

* Жодних дужок, поки вони не обов'язкові
* Завжди порожній рядок перед `@if`
* Завжди розрив рядка після відкриття фігурної дужки `{`
* `@else` на одному рядку з попередньою закриваючою дужкою `}`
* Завжди новий порожній рядок після останньої закриваючої дужки `}`

> Завжди розміщуйте змінну частину в умові з лівої сторони, а очікуваний/неочікуваний результат з правої. Перевернуті умови часто складніше читати, особливо розробникам з невеликим досвідом.

Завдяки наявності у Sass комплексних структур даних, таких як списки та мапи (словники), не дивує і можливість перебору по цих об'єктах.

Тим не менш, наявність циклів, як правило, має на увазі помірно складну логіку, що, ймовірно, не відноситься до Sass. Перед використанням циклу переконайтеся, що він має сенс, і що він вирішує завдання.

#### Директива @each <a href="#each" id="each"></a>

Директива `@each`, як показує практика, використовується найчастіше із трьох циклів, передбачених Sass. Вона надає зручний функціонал для перебору списків та мап.

`@each` - це цикл, який виконає тіло директиви для кожного значення зі списку чи мапи. Це дозволяє скоротити кількість коду, який необхідно написати вручну.

{% code overflow="wrap" lineNumbers="true" %}
```scss
// @each at-rule with list
$sizes: 8, 16, 20;

@each $size in $sizes {
  p-#{$size} {
    padding: #{$size}px;
  }
}
```
{% endcode %}

Після компіляції коду отримаємо набір класів для встановлення внутрішніх полів падінгів

> При переборі мапи завжди використовуйте імена змінних `$key` і `$value` для послідовності. Це правило гарного тону при написанні коду.

{% code overflow="wrap" lineNumbers="true" %}
```scss
// @each at-rule with map
$spacers: (
  "sm": 24,
  "md": 32,
  "lg": 36,
  "xl": 68,
);

@each $key, $value in $spacers {
  .margin-#{$key} {
    margin: #{$value}px;
  }
}
```
{% endcode %}

Після компіляції коду отримаємо набір класів для встановлення зовнішніх відступів маржинів

При роботі з `@each` дотримуйтесь наступних принципів, щоб зберегти читабельність коду:

* Завжди порожній рядок перед `@each`
* Завжди новий порожній рядок після останньої закриваючої дужки `}`

#### Директива @for

Цикл `@for` може бути корисним, коли нам потрібен доступ до **лічильника циклу** - числа, яке генерується в ході перебору.

{% code overflow="wrap" lineNumbers="true" %}
```scss
// @for at-rule with calculations
$base-weight: 400;

@for $i from 0 through 3 {
  .fw-#{$base-weight+($i * 100)} {
    font-weight: $base-weight + ($i * 100);
  }
}
```
{% endcode %}

Після компіляції коду отримаємо набір класів для встановлення товщини накреслення тексту.

Під час викристання `@for` завжди використовуйте `$i` як змінну для дотримання послідовності та правил гарного тону при написанні коду. Якщо під час ітерації необхідно пройтись циклом визначену кількість разів та не потрібен доступ до лічильника циклу, його позначають як `$_`.

Не рекомендується використовувати ключове слово `to`, натомість, краще використовувати `through`. Різниця полягає в тому чи буде останій елемент під час перебору включений до циклу чи ні. З `to` елемент буде виключено з перебору, з `through` - навпаки, включено.

> Оскільки багато розробників навіть не знають, що Sass надає такі варіанти, використання обох варіантів в коді може призвести до плутанини.

При роботі з `@for` дотримуйтесь наступних принципів, щоб зберегти читабельність коду:

* Завжди порожній рядок перед `@for`
* Завжди новий порожній рядок після останньої закриваючої дужки `}`
