# Як працюють браузери

Користувачі хочуть працювати з додатками, де контент завантажується швидко, а взаємодія відбувається плавно. Розробник повинен прагнути оптимізувати свій додаток як мінімум за цими двома показниками.

Щоб зрозуміти, як покращити продуктивність та **продуктивність, яку відчуває користувач** (User Perceived Performance, **UPP**), вам необхідно розуміти, як працюють браузери.

### Огляд

Швидкі додатки дають кращі відчуття від користування. Користувачі очікують, що додаток завантажиться миттєво, а взаємодія з ним буде плавною.

Дві головні проблеми у вебпродуктивності — це **проблема швидкості мережі** та **проблема однопотоковості** браузерів.

**Мережеві затримки** — це головна перешкода для швидкого завантаження. Щоб прискорити його, розробник повинен надсилати запитувані дані якомога швидше або, принаймні, створити враження, що вони надсилаються дуже швидко. Мережеві затримки — це час, необхідний для передачі даних від джерела до браузера. Продуктивність тут — це те, що робить завантаження сторінок якомога швидшим.

Здебільшого браузери розглядаються як **однопотокові** додатки. Це означає, що вони можуть виконувати лише одну задачу в один момент часу (наприклад, виконувати JavaScript або реагувати на клік). Щоб досягти плавності взаємодії, розробник повинен забезпечити продуктивність у всьому, починаючи від плавного скролінгу і до швидкої реакції на натискання. **Час рендерингу** — це ключове поняття. Розробник повинен забезпечити таку роботу додатка, щоб усі його завдання могли бути виконані досить швидко. У такому випадку процесор буде вільний для обробки дій користувача. Для вирішення проблеми однопоточновості ви повинні зрозуміти природу браузерів і навчитися **розвантажувати основний потік** (main thread) там, де це можливо.

### Навігація

Навігація — це перший етап під час завантаження додатка. Він відбувається щоразу, коли користувач запитує сторінку, вводячи **URL** в адресний рядок браузера, натискає на посилання, надсилає заповнену форму та виконує деякі інші дії.

Одне із завдань розробника — скоротити час, який потрібен додатку, щоб етап навігації завершився. В ідеальних умовах це зазвичай не займає багато часу, але затримки мережі та пропускна здатність каналу — це перешкоди, які призводять до затримок завантаження.

#### DNS-запит

Перший крок навігації до сторінки — це пошук місця, звідки потрібно запитувати дані. Якщо ви переходите на `[https://example.com`,]\(https://example.com`,) браузер завантажує **HTML**-код сторінки з IP-адреси` 93.**184**.**216**.34\`. Якщо ви ніколи раніше не були на цьому сайті, відбудеться пошук **DNS-запису**.

Ваш браузер запитує **DNS**-запис. Зазвичай, запит містить ім'я сервера (домен), яке має бути перетворене на IP-адресу. Відповідь на цей запит якийсь час буде збережена в кеші пристрою, щоб її можна було швидко отримати під час наступного запиту до того ж сервера.

**DNS**-запит зазвичай потрібно зробити лише один раз під час завантаження сторінки. Однак, **DNS**-запити повинні бути виконані для кожного унікального імені хоста, яке запитується сторінкою. Скажімо, якщо ваші шрифти, картинки, скрипти, реклама або лічильники аналітики знаходяться на різних доменах, **DNS**-запит буде здійснено для кожного з них.

{% hint style="warning" %}
Insert image&#x20;

Mobile requests go first to the cell tower, then to a central phone company computer before being sent to the internet
{% endhint %}

Це може бути проблемою з погляду продуктивності, особливо для мобільних мереж. Коли користувач перебуває в мобільній мережі, кожен **DNS**-запит має пройти від мобільного пристрою до стільникової вежі, а вже звідти дійти до авторитетного **DNS**-сервера. Відстань та перешкоди між телефоном, вежею та сервером імен можуть значно збільшити затримку.

#### TCP Рукостискання (Handshake)

У той момент, коли IP-адреса стає відомою, браузер починає встановлення з'єднання з сервером за допомогою **триетапного рукостискання TCP** (**TCP** three-way handshake). Цей механізм розроблений так, щоб два пристрої, які намагаються встановити зв'язок, могли обмінятися параметрами з'єднання, перш ніж приступати до передачі даних. Найчастіше — через захищене з'єднання **HTTPS**.

Триетапне рукостискання **TCP** — це техніка, яку дуже часто згадують як _**SYN**-**SYN**-**ACK**_ (якщо бути точніше, `**SYN**`, `**SYN**-**ACK**`, `**ACK**`), оскільки під час встановлення з'єднання передаються 3 повідомлення. Це означає, що перш ніж встановиться з'єднання, браузер повинен обмінятися ще трьома повідомленнями з сервером.

#### TLS Переговори (Negotiation)

Для встановлення безпечних з'єднань з використанням **HTTPS** потрібне ще одне рукостискання. Цього разу — **переговори TLS** (**TLS** negotiation). На цьому кроці визначається, який шифр буде використовуватися для шифрування з'єднання, засвідчується надійність сервера і встановлюється безпечне з'єднання. Цей крок також вимагає кількох додаткових повідомлень, якими повинні обмінятися сервер і браузер, перш ніж дані будуть надіслані.

{% hint style="warning" %}
Insert image&#x20;

The DNS lookup, the TCP handshake, and 5 steps of the TLS handshake including clienthello, serverhello and certificate, clientkey and finished for both server and client.
{% endhint %}

І хоча забезпечення безпеки з'єднання знижує швидкість завантаження додатка, безпечне з'єднання варте витрат на нього, оскільки в цьому випадку дані не можуть бути дешифровані третьою стороною.

Після обміну вісьмома повідомленнями (**DNS**, **TCP**, **TLS**), браузер, нарешті, досягає всіх умов, щоб зробити запит.

### Відповідь на запит

Щойно ми встановили з'єднання з вебсервером, браузер відправляє ініціюючий **HTTP `**GET**` запит** від імені користувача. Найчастіше запитується **HTML**-файл. У момент, коли сервер отримує запит, він починає відповідь з надсилання заголовків відповіді та вмісту **HTML**-файлу.

html

```html
<!doctype html>
<html>
    <head>
    <meta charset=***UTF**-8* />
    <title>My simple page</title>
    <link rel=*stylesheet* src=*styles.css* />
    <script src=*myscript.js*></script>
    </head>
    <body>
    <h1 class=*heading*>My Page</h1>
    <p>A paragraph with a <a href=*[https://example.com/about*>link</a></p>](https://example.com/about*>link</a></p>)
    <div>
    <img src=*myimage.jpg* alt=*image description* />
    </div>
    <script src=*anotherscript.js"></script>
    </body>
</html>
```

Ця відповідь містить у собі перший байт отриманих даних. **Час до першого байта** (Time to First Byte, **TTFB**) — це час між моментом, коли користувач відправив запит (наприклад, натиснувши на посилання), і моментом отримання першого пакета даних **HTML**. Перший пакет зазвичай містить 14КБ даних.

У прикладі вище відповідь значно менша, ніж 14КБ; скрипти та стилі, перераховані у відповіді, не будуть запитані, поки браузер не обробить відповідь. Процес обробки відповіді — парсинг — ми обговоримо окремо.

#### TCP повільний старт / правило 14kb

Обсяг першого пакета даних — завжди **14KB**. Це частина специфікації **TCP slow start** (повільний старт **TCP**) — алгоритму, який балансує швидкість з'єднання. Таке правило дозволяє поступово, за необхідності, збільшувати розміри переданих даних, поки не буде визначена максимальна пропускна здатність каналу.

В алгоритмі **TCP** slow start кожен наступний відправлений сервером пакет збільшується в розмірі вдвічі. Наприклад, розмір другого пакета буде близько 28КБ. Розмір пакетів буде збільшуватися, доки не досягне якогось порогового значення або не зіткнеться з проблемою перевантаження.

{% hint style="warning" %}
Insert image

TCP slow start
{% endhint %}

Якщо ви колись чули про _правило 14КБ_, то повинні розуміти, що оптимізація продуктивності завантаження має враховувати обмеження цього початкового запиту. Повільний старт **TCP** дозволяє плавно прискорювати передачу даних так, щоб уникнути проблеми перевантаження, коли багато даних очікують відправки, але не відправляються через обмеження каналу.

#### Контроль перевантаження

Будь-яке з'єднання має обмеження, пов'язані з апаратною та мережевою системами. Якщо сервер відправить занадто багато пакетів за раз — вони можуть бути відкинуті (загублені). Для того, щоб уникнути таких проблем, браузер повинен реагувати на отримання пакетів і підтверджувати, що він їх отримує. Така відповідь-підтвердження називається **Aknowledgements (ACK)**. Якщо через обмеження з'єднання браузер не отримає даних, то він не надішле підтверджень **ACK**. У цьому випадку сервер зареєструє, що якісь пакети не дійшли, і надішле їх заново, що призведе до зайвої роботи сервера та додаткового навантаження на мережу.

### Парсинг

Щойно браузер отримує перший шматочок даних, він одразу починає обробляти інформацію. Ця обробка називається _**Парсинг**_ (Parsing). Під час парсингу отримані дані перетворюються на **DOM** та **CSSOM**, які безпосередньо беруть участь у відмальовуванні.

**DOM** (Об’єктна Модель Документа) — це внутрішнє представлення розмітки **HTML** у вигляді дерева об'єктів. Браузер надає доступ до маніпуляції об'єктами цієї моделі через різні JavaScript **API**.

Навіть якщо відповідь на запит більша за 14КБ, браузер все одно починає парсинг даних і намагається відмалювати сторінку з тими даними, які вже доступні. Саме тому під час оптимізації продуктивності дуже важливо включати в початковий 14КБ-пакет усі необхідні для рендерингу дані — так браузер зможе швидше почати формування сторінки. Однак, перш ніж що-небудь з'явиться на екрані, **HTML**, **CSS** і JavaScript повинні бути оброблені.

#### Побудова дерева об'єктної моделі документа (DOM)

Ми вже розповідали про п'ять кроків на **критичному шляху рендерингу** (Critical Rendering Path).

Перший крок — це обробка розмітки **HTML** і побудова дерева **DOM**. Обробка **HTML** включає в себе **токенізацію** (розбиття коду на дрібні _слова_ або токени) і побудову дерева. **HTML**-токени складаються з тегів старту і фінішу, а також атрибутів. Якщо документ сформований правильно, його обробка прямолінійна і швидка. Парсер (обробник) перетворює вхідні токени в документ і будує дерево документа.

Об'єктна модель документа (**DOM**) описує вміст документа. Елемент `<html>` — це перший тег і кореневий елемент дерева документа. Дерево відображає зв'язки та ієрархію між різними тегами. Теги, вкладені в інші теги, є дочірніми (дітьми). Чим більше існує вузлів у дереві, тим складніше це дерево побудувати.

{% hint style="warning" %}
Insert image

The DOM tree for our sample code, showing all the nodes, including text nodes
{% endhint %}

Коли парсер знаходить **неблокуючі ресурси** (наприклад, зображення), браузер відправляє запит на завантаження ресурсів, але сам продовжує обробку. Обробка може тривати, коли виявлено посилання на **CSS**-файл, але якщо виявлено `<script>`, особливо якщо він без параметрів `async` або `defer` — такий скрипт вважається **блокуючим** і призупиняє обробку **HTML** до завершення завантаження скрипта. Незважаючи на те, що сканер попереднього завантаження (про нього нижче) браузера може знаходити і запитувати такі скрипти заздалегідь, складні та об'ємні скрипти все ще можуть стати причиною помітних затримок завантаження сторінки.

#### Сканер попереднього завантаження (Preload Scanner)

Побудова дерева **DOM** займає весь основний потік. Оскільки це явно вузьке місце в продуктивності, був створений особливий **сканер попереднього завантаження**. Він обробляє доступний вміст документа і запитує високопріоритетні ресурси (**CSS**, JavaScript і шрифти). Завдяки цьому сканеру нам не потрібно чекати, поки парсер дійде до конкретного місця, де викликається ресурс. Він запитує й отримує ці дані заздалегідь, у фоновому режимі, так що коли основний потік **HTML**-парсера доходить до запиту ресурсу, висока ймовірність, що ресурс вже запитаний або знаходиться в процесі завантаження. Оптимізації, які дає цей сканер, зменшують час блокування рендерингу.

html

`html <link rel=*stylesheet* src=*styles.css* /> <script src=*myscript.js* async></script> <img src=*myimage.jpg* alt=*image description* /> <script src=*anotherscript.js* async></script>`

У прикладі вище основний потік обробляє **HTML** і **CSS**. Водночас сканер попереднього завантаження знаходить скрипти та зображення і починає їх завантаження. Щоб зробити скрипт неблокуючим, додайте атрибут `async` або, у випадку, якщо порядок завантаження скриптів важливий, атрибут `defer`.

Очікування отримання **CSS** не блокує парсинг **HTML**, але воно **блокує JavaScript**, тому що JavaScript часто використовується для вибірки вузлів документа за **CSS**-селекторами.

#### Побудова моделі стилів CSSOM

Другий крок на критичному шляху рендерингу — це обробка **CSS** і побудова дерева **CSSOM**. **CSSOM** (Об’єктна Модель **CSS**) схожа на **DOM**. І **DOM**, і **CSSOM** — це дерева. Вони є незалежними структурами даних. Браузер перетворює **CSS**-файли на _карту стилів_, яку він може зрозуміти і з якою може працювати. Браузер зчитує кожен набір правил у **CSS**, створює дерево вузлів з батьками, дітьми та сусідами, ґрунтуючись на **CSS**-селекторах.

Як і з **HTML**, браузер повинен перетворити отримані правила **CSS** на щось, з чим він може працювати. Таким чином, весь цей процес — це повторення формування **DOM**, тільки для **CSS**.

Дерево **CSSOM** включає в себе **стилі user agent** (агента користувача) — це стилі, які браузер додає за замовчуванням. Браузер починає побудову моделі з найбільш загальних правил для кожного вузла, поступово застосовуючи більш специфічні правила. Іншими словами, він застосовує правила каскадно. Звідси і назва **CSS** — Cascading Style Sheets (Каскадні Таблиці Стилів).

Побудова **CSSOM** відбувається дуже швидко. Вона настільки швидка, що найчастіше включається в показник _Recalculate Styles_ (Повторне обчислення стилів) в інструментах розробника. Цей показник показує загальний час обробки стилів. З погляду оптимізації продуктивності тут нема чого робити, оскільки побудова **CSSOM**, загалом, займає навіть менше часу, ніж **DNS**-запит.

#### Інші процеси

**Компіляція JavaScript**

Поки **CSS** оброблений і **CSSOM** створений, інші ресурси, наприклад, JavaScript-файли, продовжують завантажуватися (завдяки сканеру попереднього завантаження). JavaScript після закінчення завантаження повинен бути інтерпретований, скомпільований, оброблений і виконаний. Скрипти перетворюються на **абстрактне синтаксичне дерево** (**AST**). Деякі браузери беруть Abstract Syntax Tree і передають його в інтерпретатор, який перетворює дерево на **байт-код**. Байт-код виконується в основному потоці. Весь цей процес називається компіляцією.

**Побудова дерева доступності**

Браузер також будує **дерево доступності** (Accessibility Tree), яке використовується пристроями-помічниками (наприклад, скрінрідерами) для розуміння та інтерпретації контенту. **Об'єктна модель доступності** (**AOM**) — це семантична версія **DOM**. Браузер оновлює **AOM** у той же момент, коли оновлюється **DOM**. Водночас дерево доступності не може бути змінене допоміжними технологіями.

Поки модель **AOM** не побудована, вміст сторінки недоступний для скрінрідерів (зчитувачів екрана) та голосових помічників.

### Рендеринг

Етапи рендерингу включають в себе **стилізацію (style)**, **компонування (layout)**, **відмальовування (paint)** і, в деяких випадках, **композицію (composition)**. Дерева **CSSOM** і **DOM**, створені на попередньому етапі, комбінуються в **дерево рендерингу (render tree)**, яке потім використовується для розрахунку положення кожного видимого елемента. Після цього елементи будуть відмальовані на екрані. У деяких випадках вміст може бути винесений на окремі **шари (layers)** і поєднаний (композиція) — такий підхід збільшує продуктивність, дозволяючи відмальовувати вміст екрана на **GPU (графічному процесорі)** замість **CPU** (центрального процесора). Це звільняє основний потік.

#### Стилізація (Style)

Третій крок на критичному шляху рендерингу — це комбінування **DOM** і **CSSOM** у дерево рендерингу. Конструювання цього дерева починається з проходу всього **DOM**-дерева від кореня, з виявленням кожного видимого вузла.

Елементи, які не повинні бути показані, наприклад, `<head>` та їхні діти, або будь-які елементи з `display:none` (наприклад, `script { display: none; }`), не будуть включені в дерево рендерингу, оскільки вони не повинні бути відмальовані. Вузли з правилом `visibility: hidden` включаються в дерево рендерингу, оскільки вони все одно займають своє місце (просто вони прозорі).

Кожен видимий вузол має свої правила з **CSSOM**. Дерево рендерингу містить усі видимі вузли з їхнім вмістом та обчисленими стилями. Стилі визначаються шляхом застосування всіх відповідних правил з використанням **CSS**-каскаду.

#### Компонування (Layout)

Четвертий крок на критичному шляху рендерингу — це запуск компонування (layout) елементів дерева рендерингу. На цьому етапі обчислюється геометрія кожного вузла, тобто **ширина, висота та положення** елементів. **Reflow (перекомпонування)** — це будь-який подальший процес визначення розмірів і позиції для будь-якої з частин або цілого документа.

Щойно дерево рендерингу побудоване — починається layout. Дерево несе в собі інформацію про те, які вузли повинні бути відмальовані, і які стилі повинні бути застосовані, але в дереві немає ніякої інформації про розміри та позиції елементів. Щоб визначити ці значення, браузер починає обхід дерева.

На вебсторінці практично всі елементи — це прямокутники (boxes). Різні пристрої та налаштування мають на увазі незліченну кількість різних розмірів видимої області (viewport). На початковій фазі браузер, враховуючи розмір видимої області, визначає, які розміри повинні мати різні елементи на екрані. Використовуючи розмір видимої області як базис, процес починає обчислення з елемента `body`, потім переходить до його нащадків, обчислює розміри кожного елемента.

Момент, коли позиція і розміри вузлів обчислені, називається **layout**. Наступні обчислення позицій і розмірів називаються **reflow**. У нашому прикладі початковий layout відбувається до того, як зображення отримано. Оскільки ми не задали розмір зображення, у момент отримання зображення відбудеться reflow.

#### Відмальовування (Paint)

Останній крок критичного шляху рендерингу — це відмальовування кожного окремого вузла на екрані. Момент, коли це відбувається вперше, називається **first meaningful paint** (перше значуще відмальовування). Під час фази відмальовування або **растеризації**, браузер конвертує кожен _контейнер_ (box) у справжні пікселі на екрані (нагадаємо, що дані контейнерів формуються на етапі layout). Відмальовування має на увазі малювання кожної візуальної частинки елемента на екрані (текст, кольори, рамки, тіні).

Щоб забезпечити плавне прокручування та анімацію, весь процес рендерингу повинен виконуватися дуже швидко. В ідеалі, браузер має встигати генерувати новий кадр кожні **16.67 мс** (**1000** мс / 60 кадрів на секунду = 60 **FPS**). Це дуже мало часу! Для того, щоб зробити початкове та повторне відмальовування швидшим, можна розбити весь процес на кілька **шарів** (layers). Коли це трапляється — стає необхідною композиція.

Відмальовування може розбити елементи в дереві рендерингу на шари. Щоб прискорити їх рендер, браузер може перенести відмальовування різних шарів на **GPU** (замість основного потоку **CPU**). Для перенесення обчислень відмальовування на **GPU** ви можете використовувати деякі спеціальні **HTML**-теги, наприклад `<video>` і `<canvas>`, а також **CSS**-властивості `opacity`, `transform` і `will-change`. Вузли, створені таким чином, будуть відмальовані на їхньому власному шарі.

Шари покращують продуктивність анімацій, але з погляду управління пам'яттю вони _дорогі_. Тому намагайтеся не використовувати їх там, де в них немає необхідності.

#### Композиція (Compositing)

Коли розділи документа відмальовані на різних шарах, а один шар знаходиться над іншим або перекриває його, стає необхідною **композиція**. Цей крок дозволяє браузеру гарантувати, що кожен шар відмальований на екрані в правильному порядку, а вміст відображається коректно.

При довантаженні раніше запитаних ресурсів (наприклад, зображень, для яких не був вказаний розмір) може знадобитися перерахувати розміри і положення елементів. Цей перерахунок — **reflow (перекомпонування)** — запускає **repaint (перемальовування)** і **re-composite (повторну композицію)**. Якби ми заздалегідь визначили розмір зображення, перерахунок не був би необхідний, і в цьому випадку тільки той шар, який повинен бути перемальований, — був би перемальований. Але оскільки ми не визначили розмір, браузер змушений відмотати процес рендерингу назад до кроку компонування (layout) і почати процес відмальовування ще раз.

### Інтерактивність

Можна було б подумати, що щойно основний потік завершує відмальовування сторінки — _все готово_. Це не завжди так. Якщо серед ресурсів є JavaScript, завантаження якого було коректно відкладено (наприклад, `defer`), і запуск якого відбувається тільки після події `onload`, основний потік починає обробку цих скриптів. Під час цієї обробки браузер не може обробляти події скролінгу, натискань та ін.

**Time to Interactive** (**TTI**, час до інтерактивності) — це показник того, як багато часу проходить між найпершим мережевим запитом і моментом, коли сторінка стає інтерактивною. Інтерактивністю називається показник того, що сторінка відреагувала на дію користувача (наприклад, клік) протягом **50 мс**. Якщо процесор зайнятий обробкою, компіляцією і виконанням JavaScript, то браузер не може відреагувати досить швидко, а отже, сторінка вважається не інтерактивною.

У нашому прикладі, навіть незважаючи на те, що зображення завантажилося швидко, скрипт `anotherscript.js`, розмір якого досягає 2МБ, завантажується довго. У цьому випадку користувач побачить сторінку дуже швидко, але не зможе взаємодіяти з нею, поки скрипт не буде завантажений, оброблений і виконаний. Це погана практика. Намагайтеся уникати повного завантаження основного потоку.

{% hint style="warning" %}
Insert image

The main thread is occupied by the downloading, parsing and execution of a javascript file - over a fast connection
{% endhint %}

У прикладі вище завантаження вмісту **DOM** зайняло близько 1.5 секунд. Весь цей час основний потік процесу був повністю завантажений і не був здатний обробити дії користувача.
